---
title: "test"
output:
  html_document:
    df_print: paged
date: "2025-07-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(rpart)
library(testit)
library(evir)
library(treeClust)
library(lubridate)
library(dplyr)
library(extRemes)
library(rmarkdown)
```

```{r}
tempfit = fevd(surface_wind, temp5, threshold = 6, type = "GP")
tempfit$results$value
tempfit = evir::gpd(temp5$surface_wind, threshold = 6, method = "ml")
tempfit$nllh.final
```


```{r, warning=FALSE}
itempgprt <- function(y, offset, parms, wt) {
  if (is.matrix(y) && ncol(y) > 1)
    stop("Matrix response not allowed")
  if (!missing(parms) && length(parms) > 0)
    warning("parameter argument ignored")
  if (length(offset)) y <- y - offset
  sfun <- function(yval, dev, wt, ylevel, digits ) {
    paste(" Shape=", format(signif(yval, digits)),
          ", Deviance=" , format(signif(dev/wt, digits)),
          sep = '')
  }
  environment(sfun) <- .GlobalEnv
  list(y = c(y), parms = NULL, numresp = 1, numy = 1, summary = sfun)
}

etempgprt <- function(y, wt, parms) {
  threshold = quantile(y, probs = 0.95)
  leval=FALSE
  if(!has_error(try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE),silent = TRUE)){
    leval=TRUE
  }
  
  if(leval){

    fit=try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE)
    #Location parameter
    lo=fit$results$par[1]
    #Shape parameter
    sh=fit$results$par[2]
    #Scale parameter
    sc=fit$results$par[3]
    #Negative log-likelihood plus ten times the number of observation
    rss=fit$results$value

    if(rss<0){
      #Warning if the rss is negative
      print("Warning: rss negative")
    }

  }else{
    #If the fit of the GPD does not work, we penalize the evaluation by allowing a rss equal to 100000
    lo=NA
    sh=NA
    sc=NA
    rss=100000
    #rss=naive_ll_gpd_fit(y)
  }

  #print(paste(Sys.time(),": Computing..."))
  print("Running...")
  print(c(lo,sh,sc,rss))
  list(label = c(sc), deviance = rss)
}

stempgprt <- function(y, wt, x, parms, continuous) {

  #Test of the fit of the fevd function, if it works well the local variable lparent takes the value TRUE, FALSE in the contrary case

  #Test if the fevd fit works well
  threshold = quantile(y, probs = 0.95)
  if(!has_error(try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE))) {
    #If yes lparent=TRUE
    lparent=TRUE
    fitparent=fevd(y, threshold = threshold, type = "PP")
  } else {
    #Else lparent=FALSE
    lparent=FALSE
  }

  #Continuous x variable
  if (continuous) {
    #n is the number of observations
    n <- length(y)
    #Initialisation of the goodness and the direction vectors at 0
    #Meaning that, for now, all of the splits are useless
    goodness=double(n-1)
    direction=goodness

    for (i in 1:(n-1)) {
      thresholdmoins = quantile(y[1:i], prob = 0.95)
      thresholdplus = quantile(y[(i+1):n], prob = 0.95)
      if( #lparent &
        length(1:i) > 30 &
        length((i+1):n) > 30){
        if(
          !has_error(try(fevd(y[1:i], threshold = thresholdmoins, type = "PP"),silent = TRUE)) &
          !has_error(try(fevd(y[(i+1):n], threshold = thresholdplus, type = "PP"),silent = TRUE))
        ) {
          fitmoins=fevd(y[1:i], threshold = thresholdmoins, type = "PP")
          fitplus=fevd(y[(i+1):n], threshold = thresholdplus, type = "PP")

          if(lparent==TRUE & fitmoins$results$par[2]>0 & fitplus$results$par[2]>0) {
              goodness[i]=max(0,(fitparent$results$value-(fitmoins$results$value+fitplus$results$value)))
          } else {
            goodness[i]=0
          }
          direction[i]=sign(fitmoins$results$value-fitplus$results$value)
        }
      }

      if(goodness[i]<0){
        print("Warning: negative goodness")
      }

      if(goodness[i]==Inf | goodness[i]==-Inf){
        print("Warning: + or - infinity goodness")
      }

    }
    print("Finished split")
    list(goodness = goodness, direction = direction)
  } else {
    #Categorial x variable

    #We order the categories by their means
    ux <- sort(unique(x))
    ymean <- tapply(y, x, mean)
    ord <- order(ymean)
    #n is the number of categories
    n <- length(ord)

    #Initialisation of the goodness and the direction vectors at 0
    #Meaning that, for now, all of the splits are useless
    goodness=double(n-1)
    direction=goodness

    for (i in 1:(n-1)){
      #Creation of two vectors ymoins and yplus gathering respectively observations at the left (resp. at the right ) of the split
      ymoins=y[x==ux[ord[1]]]
      j=2
      while (j<=i){
        ymoins=c(ymoins,y[x==ux[ord[j]]])
        j=j+1
      }

      yplus=y[x==ux[ord[i+1]]]
      j=2
      while(i+j<=n){
        yplus=c(yplus,y[x==ux[ord[i+j]]])
        j=j+1
      }


      #Test if the evaluation of losses for the resulating children nodes have to be made
      #It is the case, if lparent=TRUE, if each children nodes gathered at least 21 observations and if the fevd splits on the children nodes work well

      thresholdmoins = quantile(y[1:i], prob = 0.95)
      thresholdplus = quantile(y[(i+1):n], prob = 0.95)
      if(
        #lparent &
        length(ymoins) > 30 &
        length(yplus) > 30
      ){

        if(
          !has_error(try(fevd(ymoins, threshold = thresholdmoins, type = "PP"),silent = TRUE)) &
          !has_error(try(fevd(yplus, threshold = thresholdplus, type = "PP"),silent = TRUE))     ){

          #If yes, computation of the fevd fit on children nodes and attribution of the resulting goodness and direction

          fitmoins=fevd(ymoins, threshold = thresholdmoins, type = "PP")
          fitplus=fevd(yplus, threshold = thresholdplus, type = "PP")

          #Reminder: the more the value of the goodness is closed to 0 the less purely the node is)

          #if(fitmoins$par.ests[1]>0 & fitplus$par.ests[1]>0){
            if(lparent==TRUE & fitmoins$results$par[2]>0 & fitplus$results$par[2]>0){
              goodness[i]=max(0,(fitparent$results$value-(fitmoins$results$value+fitplus$results$value)))
            }else{
              goodness[i]=0
            }
          direction[i]=sign(fitmoins$results$value-fitplus$results$value)
        }
      }

      if(goodness[i]<0){
        print("Warning: negative goodness")
      }

      if(goodness[i]==Inf | goodness[i]==-Inf){
        print("Warning: + or - infinity goodness or rate of fit distinct of 1")
      }

    }
    print("Finished split")
    list(goodness = goodness, direction = ux[ord])
  }
}

GPRT_method_xi_in_R_plus=list(eval = etempgprt, split = stempgprt, init = itempgprt)
positive_nll=function(x){
  if(x>0){
    return(x+1)
  }else{
    return(exp(x))
  }
}

wind_speed = read.csv("pearson_wind_data.csv")
wind_speed$valid_time = as.Date(wind_speed$valid_time, format = "%Y-%m-%d")
wind_speed$Year = year(wind_speed$valid_time)
wind_speed$Month = month(wind_speed$valid_time)
wind_speed = wind_speed %>% mutate(summer_index = case_when(Month %in% c(6, 7, 8) ~ 1,
                                                            TRUE ~ 0))

temp5 = wind_speed[, !(names(wind_speed) %in% c("valid_time", "pressure_level", "latitude", "longitude", "Month", "day_of_year"))] %>% filter(Year == 2000)
GPRT_unpruned=rpart(data = temp5,
                    formula = surface_wind ~ low.level_wind + jet_stream,
                    method = GPRT_method_xi_in_R_plus,
                    #control = rpart.control(cp=0,minsplit=max(dim(data_sample)[1]/20,15), minbucket=max(dim(data_sample)[1]/60,7), maxcompete=0, maxsurrogate=0),
                    control = rpart.control(cp=0, minsplit=50, minbucket=30, 
                                            maxcompete=0, maxsurrogate=0),
                    xval=0)
```

```{r}
print(GPRT_unpruned)
printcp(GPRT_unpruned)
```

```{r}
temp_fit = rpart(formula = surface_wind ~ ., data = temp5, method = "class")
print(temp_fit)
```

```{r, warning = FALSE}
itemp <- function(y, offset, parms, wt) {
  if (is.matrix(y) && ncol(y) > 1)
  stop("Matrix response not allowed")
  if (!missing(parms) && length(parms) > 0)
  warning("parameter argument ignored")
  if (length(offset)) y <- y- offset
  sfun <- function(yval, dev, wt, ylevel, digits ) {
    paste(" mean=", format(signif(yval, digits)),
          ", MSE=" , format(signif(dev/wt, digits)), sep = '')
  }
  environment(sfun) <- .GlobalEnv
  list(y = c(y), parms = NULL, numresp = 1, numy = 1, summary = sfun)
}

etemp <- function(y, wt, parms) {
  wmean <- sum(y*wt)/sum(wt)
  rss <- sum(wt*(y-wmean)^2)
  list(label = wmean, deviance = rss)
}

stemp <- function(y, wt, x, parms, continuous) {
  # Center y
  n <- length(y)
  y <- y- sum(y*wt)/sum(wt)
  if (continuous) {
    # continuous x variable
    temp <- cumsum(y*wt)[-n]
    left.wt <- cumsum(wt)[-n]
    right.wt <- sum(wt)- left.wt
    lmean <- temp/left.wt
    rmean <--temp/right.wt
    goodness <- (left.wt*lmean^2 + right.wt*rmean^2)/sum(wt*y^2)
    list(goodness = goodness, direction = sign(lmean))
  } else {
    # Categorical X variable
    ux <- sort(unique(x))
    wtsum <- tapply(wt, x, sum)
    ysum <- tapply(y*wt, x, sum)
    means <- ysum/wtsum
    # For anova splits, we can order the categories by their means
    # then use the same code as for a non-categorical
    ord <- order(means)
    n <- length(ord)
    temp <- cumsum(ysum[ord])[-n]
    left.wt <- cumsum(wtsum[ord])[-n]
    right.wt <- sum(wt)- left.wt
    lmean <- temp/left.wt
    rmean <--temp/right.wt
    list(goodness= (left.wt*lmean^2 + right.wt*rmean^2)/sum(wt*y^2),
    direction = ux[ord])
  }
}
GPRT_method_xi_in_R_plus=list(eval = etemp, split = stemp, init = itemp)
GPRT_unpruned=rpart(data = temp5,
                    formula = surface_wind ~ low.level_wind + jet_stream,
                    method = GPRT_method_xi_in_R_plus,
                    #control = rpart.control(cp=0,minsplit=max(dim(data_sample)[1]/20,15), minbucket=max(dim(data_sample)[1]/60,7), maxcompete=0, maxsurrogate=0),
                    control = rpart.control(cp=0.001, minsplit=50, minbucket=30, 
                                            maxcompete=0, maxsurrogate=0),
                    xval=0)
```

```{r}
plot(GPRT_unpruned)
printcp(GPRT_unpruned)
```













