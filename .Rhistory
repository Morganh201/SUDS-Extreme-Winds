plot(fit2, "trace")
fit2 = fevd(TMX1, PORTw, location.fun = ~AOindex, units = 'deg C')
plot(fit2)
plot(fit2, "trace")
fit2 = fevd(TMX1, PORTw, location.fun = ~AOindex, units = 'deg C')
plot(fit2)
plot(fit2, "trace")
fit1 = fevd(TMX1, PORTw, units = 'deg C')
lr.test(fit1, fit2)
v = make.qcov(fit2, vals = list(mu1 = c(-1, 1)))
return.level(fit2, return.period = c(2, 20, 100), qcov=v)
ci(fit2, type='parameter')
fit2 = fevd(TMX1, PORTw, location.fun = ~AOindex, units = 'deg C')
plot(fit2)
ci(fit2, type='parameter')
plot(fit2, "trace")
fit3 <- fevd(TMX1, PORTw, location.fun = ~ AOindex, scale.fun = ~ AOindex, use.phi = TRUE, units = "deg C")
plot(fit3)
fit3 <- fevd(TMX1, PORTw, location.fun = ~ AOindex, scale.fun = ~ AOindex, use.phi = TRUE, units = "deg C")
plot(fit3)
lr.test(fit3, fit2)
data("Prec", package = "extRemes")
data("Fort", package = "extRemes")
data("Fort", package = "extRemes")
fitFC = fevd(Prec, Fort, threshold = 0.395, type="GP")
fitFC2 = fevd(Prec, Fort, threshold = 0.395, scale.fun = ~ cos(2 * pi * tobs / 365.25) + sin(2 * pi * tobs / 365.25), type = "GP", use.phi = TRUE, units = "inches")
lr.test(fitFC, fitFC2)
data("Fort", package = "extRemes")
plot(Fort$Prec)
data("Fort", package = "extRemes")
plot(Fort$Prec, type='l')
library(dplyr)
data("Fort", package = "extRemes")
temp = Fort %>% filter(year %in% c(1900:1905))
plot(temp, type='l')
library(dplyr)
data("Fort", package = "extRemes")
temp = Fort %>% filter(year %in% c(1900, 1901))
plot(temp, type='l')
library(dplyr)
data("Fort", package = "extRemes")
temp = Fort %>% filter(year %in% c(1900))
plot(temp, type='l')
library(dplyr)
data("Fort", package = "extRemes")
temp = Fort %>% filter(year %in% c(1900:1905))
plot(temp, type='l')
library(dplyr)
data("Fort", package = "extRemes")
temp = Fort %>% filter(year %in% c(1900:1905))
plot(temp$Prec, type='l')
library(dplyr)
data("Fort", package = "extRemes")
temp = Fort %>% filter(year %in% c(1900:1901))
plot(temp$Prec, type='l')
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)))
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)), qcov=v, lower.tail = FALSE)
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 730)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)), qcov=v, lower.tail = FALSE)
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 730)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)), qcov=v, lower.tail = FALSE)
FCprobs
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 730)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)), qcov=v, lower.tail = FALSE)
plot(FCprobs)
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 365)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)), qcov=v, lower.tail = FALSE)
plot(FCprobs)
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 730)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365), rep(4.63, 365)), qcov=v, lower.tail = FALSE)
plot(FCprobs)
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 365)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365)), qcov=v, lower.tail = FALSE)
v = matrix(1, 730, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 730)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365)), qcov=v, lower.tail = FALSE)
v = matrix(1, 365, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25, 2))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25, 2))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 365)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365)), qcov=v, lower.tail = FALSE)
plot(FCprobs)
v = matrix(1, 365, 5)
v[, 2] = cos(2 * pi * rep(1:365 / 365.25))
v[, 3] = sin(2 * pi * rep(1:365 / 365.25))
v[, 5] = 0.395
v = make.qcov(fitFC2, vals = v, nr = 365)
FCprobs = pextRemes(fitFC2, q = c(rep(1.54, 365)), qcov=v, lower.tail = FALSE)
plot(FCprobs)
setwd("C:/Users/morga/SUDS-Extreme-Winds")
load("C:/Users/morga/SUDS-Extreme-Winds/regression_tree.RData")
knitr::opts_chunk$set(echo = TRUE)
GPRT_unpruned
rpart(surface_wind ~ ., data = temp5, method = "anova", control = rpart.control(cp=0, minsplit=50, minbucket=30,
maxcompete=0, maxsurrogate=0, maxdepth = 5), xval = 0)
library(rpart)
tempfit = rpart(surface_wind ~ ., data = temp5, method = "anova", control = rpart.control(cp=0, minsplit=50, minbucket=30,
maxcompete=0, maxsurrogate=0, maxdepth = 5), xval = 0)
tempfit
rpart.plot(tempfit)
tempfit
plot(tempfit)
library(rpart)
tempfit = rpart(surface_wind ~ ., data = temp5, method = "anova", control = rpart.control(cp=0, minsplit=50, minbucket=30,
maxcompete=0, maxsurrogate=0), xval = 0)
tempfit
plot(tempfit)
library(rpart)
tempfit = rpart(surface_wind ~ ., data = temp5, method = "anova", control = rpart.control(cp=0.001, minsplit=50, minbucket=30,
maxcompete=0, maxsurrogate=0), xval = 0)
tempfit
plot(tempfit)
tempfit
itempgprt <- function(y, offset, parms, wt) {
if (is.matrix(y) && ncol(y) > 1)
stop("Matrix response not allowed")
if (!missing(parms) && length(parms) > 0)
warning("parameter argument ignored")
if (length(offset)) y <- y - offset
sfun <- function(yval, dev, wt, ylevel, digits ) {
paste(" Shape=", format(signif(yval, digits)),
", Deviance=" , format(signif(dev/wt, digits)),
sep = '')
}
environment(sfun) <- .GlobalEnv
list(y = c(y), parms = NULL, numresp = 3, numy = 1, summary = sfun)
}
etempgprt <- function(y, wt, parms) {
threshold = quantile(y, probs = 0.95)
leval=FALSE
if(!has_error(try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE),silent = TRUE)){
leval=TRUE
}
if(leval){
fit=try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE)
#Location parameter
lo=fit$results$par[1]
#Shape parameter
sh=fit$results$par[2]
#Scale parameter
sc=fit$results$par[3]
#Negative log-likelihood plus ten times the number of observation
rss=positive_nll(fit$results$value)+10*length(y)
if(rss<0){
#Warning if the rss is negative
print("Warning: rss negative")
}
}else{
#If the fit of the GPD does not work, we penalize the evaluation by allowing a rss equal to 100000
lo=NA
sh=NA
sc=NA
rss=100000
#rss=naive_ll_gpd_fit(y)
}
#print(paste(Sys.time(),": Computing..."))
print("Running...")
print(c(lo,sh,sc,rss))
list(label = c(lo,sh,sc), deviance = rss)
}
stempgprt <- function(y, wt, x, parms, continuous) {
#Test of the fit of the fevd function, if it works well the local variable lparent takes the value TRUE, FALSE in the contrary case
#Test if the fevd fit works well
threshold = quantile(y, probs = 0.95)
if(!has_error(try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE))) {
#If yes lparent=TRUE
lparent=TRUE
fitparent=fevd(y, threshold = threshold, type = "PP")
} else {
#Else lparent=FALSE
lparent=FALSE
}
#Continuous x variable
if (continuous) {
#n is the number of observations
n <- length(y)
#Initialisation of the goodness and the direction vectors at 0
#Meaning that, for now, all of the splits are useless
goodness=double(n-1)
direction=goodness
for (i in 1:(n-1)) {
thresholdmoins = quantile(y[1:i], prob = 0.95)
thresholdplus = quantile(y[(i+1):n], prob = 0.95)
if( #lparent &
length(1:i) > 30 &
length((i+1):n) > 30){
if(
!has_error(try(fevd(y[1:i], threshold = thresholdmoins, type = "PP"),silent = TRUE)) &
!has_error(try(fevd(y[(i+1):n], threshold = thresholdplus, type = "PP"),silent = TRUE))
) {
fitmoins=fevd(y[1:i], threshold = thresholdmoins, type = "PP")
fitplus=fevd(y[(i+1):n], threshold = thresholdplus, type = "PP")
if(lparent==TRUE & fitmoins$results$par[2]>0 & fitplus$results$par[2]>0) {
goodness[i]=max(0,(fitparent$results$value-(fitmoins$results$value+fitplus$results$value)))
} else {
goodness[i]=0
}
direction[i]=sign(fitmoins$results$value-fitplus$results$value)
}
}
if(goodness[i]<0){
print("Warning: negative goodness")
}
if(goodness[i]==Inf | goodness[i]==-Inf){
print("Warning: + or - infinity goodness")
}
}
print("Finished split")
list(goodness = goodness, direction = direction)
} else {
#Categorial x variable
#We order the categories by their means
ux <- sort(unique(x))
ymean <- tapply(y, x, mean)
ord <- order(ymean)
#n is the number of categories
n <- length(ord)
#Initialisation of the goodness and the direction vectors at 0
#Meaning that, for now, all of the splits are useless
goodness=double(n-1)
direction=goodness
for (i in 1:(n-1)){
#Creation of two vectors ymoins and yplus gathering respectively observations at the left (resp. at the right ) of the split
ymoins=y[x==ux[ord[1]]]
j=2
while (j<=i){
ymoins=c(ymoins,y[x==ux[ord[j]]])
j=j+1
}
yplus=y[x==ux[ord[i+1]]]
j=2
while(i+j<=n){
yplus=c(yplus,y[x==ux[ord[i+j]]])
j=j+1
}
#Test if the evaluation of losses for the resulating children nodes have to be made
#It is the case, if lparent=TRUE, if each children nodes gathered at least 21 observations and if the fevd splits on the children nodes work well
thresholdmoins = quantile(y[1:i], prob = 0.95)
thresholdplus = quantile(y[(i+1):n], prob = 0.95)
if(
#lparent &
length(ymoins) > 30 &
length(yplus) > 30
){
if(
!has_error(try(fevd(ymoins, threshold = thresholdmoins, type = "PP"),silent = TRUE)) &
!has_error(try(fevd(yplus, threshold = thresholdplus, type = "PP"),silent = TRUE))     ){
#If yes, computation of the fevd fit on children nodes and attribution of the resulting goodness and direction
fitmoins=fevd(ymoins, threshold = thresholdmoins, type = "PP")
fitplus=fevd(yplus, threshold = thresholdplus, type = "PP")
#Reminder: the more the value of the goodness is closed to 0 the less purely the node is)
#if(fitmoins$par.ests[1]>0 & fitplus$par.ests[1]>0){
if(lparent==TRUE & fitmoins$results$par[2]>0 & fitplus$results$par[2]>0){
goodness[i]=max(0,(fitparent$results$value-(fitmoins$results$value+fitplus$results$value)))
}else{
goodness[i]=0
}
direction[i]=sign(fitmoins$results$value-fitplus$results$value)
}
}
if(goodness[i]<0){
print("Warning: negative goodness")
}
if(goodness[i]==Inf | goodness[i]==-Inf){
print("Warning: + or - infinity goodness or rate of fit distinct of 1")
}
}
print("Finished split")
list(goodness = goodness, direction = ux[ord])
}
}
GPRT_method_xi_in_R_plus=list(eval = etempgprt, split = stempgprt, init = itempgprt)
positive_nll=function(x){
if(x>0){
return(x+1)
}else{
return(exp(x))
}
}
wind_speed = read.csv("pearson_wind_data.csv")
wind_speed$valid_time = as.Date(wind_speed$valid_time, format = "%Y-%m-%d")
wind_speed$Year = year(wind_speed$valid_time)
wind_speed$Month = month(wind_speed$valid_time)
wind_speed = wind_speed %>% mutate(summer_index = case_when(Month %in% c(6, 7, 8) ~ 1,
TRUE ~ 0))
temp5 = wind_speed[, !(names(wind_speed) %in% c("valid_time", "pressure_level", "latitude", "longitude", "Month", "day_of_year", "Year"))]
GPRT_unpruned=rpart(data = temp5,
formula = surface_wind ~ .,
method = GPRT_method_xi_in_R_plus,
control = rpart.control(cp=0, minsplit=50, minbucket=30,
maxcompete=0, maxsurrogate=0, maxdepth = 5),
xval=0)
knitr::opts_chunk$set(echo = TRUE)
library(rpart)
library(testit)
library(evir)
library(treeClust)
library(lubridate)
library(dplyr)
library(extRemes)
library(rmarkdown)
itempgprt <- function(y, offset, parms, wt) {
if (is.matrix(y) && ncol(y) > 1)
stop("Matrix response not allowed")
if (!missing(parms) && length(parms) > 0)
warning("parameter argument ignored")
if (length(offset)) y <- y - offset
sfun <- function(yval, dev, wt, ylevel, digits ) {
paste(" Shape=", format(signif(yval, digits)),
", Deviance=" , format(signif(dev/wt, digits)),
sep = '')
}
environment(sfun) <- .GlobalEnv
list(y = c(y), parms = NULL, numresp = 3, numy = 1, summary = sfun)
}
etempgprt <- function(y, wt, parms) {
threshold = quantile(y, probs = 0.95)
leval=FALSE
if(!has_error(try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE),silent = TRUE)){
leval=TRUE
}
if(leval){
fit=try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE)
#Location parameter
lo=fit$results$par[1]
#Shape parameter
sh=fit$results$par[2]
#Scale parameter
sc=fit$results$par[3]
#Negative log-likelihood plus ten times the number of observation
rss=positive_nll(fit$results$value)+10*length(y)
if(rss<0){
#Warning if the rss is negative
print("Warning: rss negative")
}
}else{
#If the fit of the GPD does not work, we penalize the evaluation by allowing a rss equal to 100000
lo=NA
sh=NA
sc=NA
rss=100000
#rss=naive_ll_gpd_fit(y)
}
#print(paste(Sys.time(),": Computing..."))
print("Running...")
print(c(lo,sh,sc,rss))
list(label = c(lo,sh,sc), deviance = rss)
}
stempgprt <- function(y, wt, x, parms, continuous) {
#Test of the fit of the fevd function, if it works well the local variable lparent takes the value TRUE, FALSE in the contrary case
#Test if the fevd fit works well
threshold = quantile(y, probs = 0.95)
if(!has_error(try(fevd(y, threshold = threshold, type = "PP"),silent = TRUE))) {
#If yes lparent=TRUE
lparent=TRUE
fitparent=fevd(y, threshold = threshold, type = "PP")
} else {
#Else lparent=FALSE
lparent=FALSE
}
#Continuous x variable
if (continuous) {
#n is the number of observations
n <- length(y)
#Initialisation of the goodness and the direction vectors at 0
#Meaning that, for now, all of the splits are useless
goodness=double(n-1)
direction=goodness
for (i in 1:(n-1)) {
thresholdmoins = quantile(y[1:i], prob = 0.95)
thresholdplus = quantile(y[(i+1):n], prob = 0.95)
if( #lparent &
length(1:i) > 30 &
length((i+1):n) > 30){
if(
!has_error(try(fevd(y[1:i], threshold = thresholdmoins, type = "PP"),silent = TRUE)) &
!has_error(try(fevd(y[(i+1):n], threshold = thresholdplus, type = "PP"),silent = TRUE))
) {
fitmoins=fevd(y[1:i], threshold = thresholdmoins, type = "PP")
fitplus=fevd(y[(i+1):n], threshold = thresholdplus, type = "PP")
if(lparent==TRUE & fitmoins$results$par[2]>0 & fitplus$results$par[2]>0) {
goodness[i]=max(0,(fitparent$results$value-(fitmoins$results$value+fitplus$results$value)))
} else {
goodness[i]=0
}
direction[i]=sign(fitmoins$results$value-fitplus$results$value)
}
}
if(goodness[i]<0){
print("Warning: negative goodness")
}
if(goodness[i]==Inf | goodness[i]==-Inf){
print("Warning: + or - infinity goodness")
}
}
print("Finished split")
list(goodness = goodness, direction = direction)
} else {
#Categorial x variable
#We order the categories by their means
ux <- sort(unique(x))
ymean <- tapply(y, x, mean)
ord <- order(ymean)
#n is the number of categories
n <- length(ord)
#Initialisation of the goodness and the direction vectors at 0
#Meaning that, for now, all of the splits are useless
goodness=double(n-1)
direction=goodness
for (i in 1:(n-1)){
#Creation of two vectors ymoins and yplus gathering respectively observations at the left (resp. at the right ) of the split
ymoins=y[x==ux[ord[1]]]
j=2
while (j<=i){
ymoins=c(ymoins,y[x==ux[ord[j]]])
j=j+1
}
yplus=y[x==ux[ord[i+1]]]
j=2
while(i+j<=n){
yplus=c(yplus,y[x==ux[ord[i+j]]])
j=j+1
}
#Test if the evaluation of losses for the resulating children nodes have to be made
#It is the case, if lparent=TRUE, if each children nodes gathered at least 21 observations and if the fevd splits on the children nodes work well
thresholdmoins = quantile(y[1:i], prob = 0.95)
thresholdplus = quantile(y[(i+1):n], prob = 0.95)
if(
#lparent &
length(ymoins) > 30 &
length(yplus) > 30
){
if(
!has_error(try(fevd(ymoins, threshold = thresholdmoins, type = "PP"),silent = TRUE)) &
!has_error(try(fevd(yplus, threshold = thresholdplus, type = "PP"),silent = TRUE))     ){
#If yes, computation of the fevd fit on children nodes and attribution of the resulting goodness and direction
fitmoins=fevd(ymoins, threshold = thresholdmoins, type = "PP")
fitplus=fevd(yplus, threshold = thresholdplus, type = "PP")
#Reminder: the more the value of the goodness is closed to 0 the less purely the node is)
#if(fitmoins$par.ests[1]>0 & fitplus$par.ests[1]>0){
if(lparent==TRUE & fitmoins$results$par[2]>0 & fitplus$results$par[2]>0){
goodness[i]=max(0,(fitparent$results$value-(fitmoins$results$value+fitplus$results$value)))
}else{
goodness[i]=0
}
direction[i]=sign(fitmoins$results$value-fitplus$results$value)
}
}
if(goodness[i]<0){
print("Warning: negative goodness")
}
if(goodness[i]==Inf | goodness[i]==-Inf){
print("Warning: + or - infinity goodness or rate of fit distinct of 1")
}
}
print("Finished split")
list(goodness = goodness, direction = ux[ord])
}
}
GPRT_method_xi_in_R_plus=list(eval = etempgprt, split = stempgprt, init = itempgprt)
positive_nll=function(x){
if(x>0){
return(x+1)
}else{
return(exp(x))
}
}
wind_speed = read.csv("pearson_wind_data.csv")
wind_speed$valid_time = as.Date(wind_speed$valid_time, format = "%Y-%m-%d")
wind_speed$Year = year(wind_speed$valid_time)
wind_speed$Month = month(wind_speed$valid_time)
wind_speed = wind_speed %>% mutate(summer_index = case_when(Month %in% c(6, 7, 8) ~ 1,
TRUE ~ 0))
temp5 = wind_speed[, !(names(wind_speed) %in% c("valid_time", "pressure_level", "latitude", "longitude", "Month", "day_of_year", "Year"))]
GPRT_unpruned=rpart(data = temp5,
formula = surface_wind ~ .,
method = GPRT_method_xi_in_R_plus,
control = rpart.control(cp=0, minsplit=50, minbucket=30,
maxcompete=0, maxsurrogate=0, maxdepth = 5),
xval=0)
